# Domain Specific Languages and Code Generation in .NET

C# is a great language. However, as a general purpose language, it can sometimes be tedious to express simple concepts. This is where we would often like to have a domain specific language (DSL) that is specially designed to express information more succinctly. As an example that most people would be familiar with, lets look at .resx files. A .resx file is a domain specific language for defining localized strings, and other types of resources. The implementation language is xml, but in reality no one looks at the raw xml, they use the Visual Studio resource design surface for authoring the resources, in essense a "visual DSL". I want to look at resx files, specifically, because I want to discuss some drawbacks to the way that they are implemented.

The .resx file uses the "Custom Tool" feature of Visual Studio, which is also known as a "Single File Generator" (SFG): the name of the API that is used to implement them. An SFG takes an input file, and produces a single output file. You can see the output file, as it is included in your project, nested underneath the input .resx file in the Solution Explorer.

Since SFGs are implemented as an extension to Visual Studio (VS), they *require* Visual Studio in order to work. This can be a problem if someone on your team likes to work in a different development environment. You cannot (at least not easily) generate the output from a command line build. If you have VS, this isn't usually a problem, because the output file is included in your project, and thus will be included in your source control repository.

One of the problems I see with .resx files is that they require the "visual DSL" to provide a decent experience. Without the design surface, editing a .resx file in xml form... sucks. Like, really suck. I'm pretty sure there are approximately zero people on earth that could write a .resx file from scratch, by hand. To me, that doesn't describe source code! But we are checking it into our *source* code repository.

The second problem, is that the output file is also not *source* code; it is *generated* code. The source for the generated code is the .resx xml, that is all that should be checked into my source repository. I don't want generated code checked into my source repository, because the differences in the output will (should) be more clearly epxressed by the input .resx. And the output should be easily generated as long as I have the input file, and the tool to generate the code. Additionally, if someone were to edit the generated code, their modifications would be lost the next time the file was regenerated. For this reason, code files generated in this way usually emit a warning comment at the top of the file stating that "This code was generated by a tool", and end in a .g.cs extension to indicate that the file was generated and shouldn't be modified. I don't want files that I shouldn't modify to be included in my source repository if I can avoid it.

I strongly believe that everything in a clean source code respository should be hand-written files that are easily diffable, and hence, easily mergable. I don't want to have to deal with merging changes to my DSL file, and also have to merge the content that it generated.

Single File Generators are one approach to implementing a DSL. Another approach is to create a custom MSBuild task. An MSBuild task eliminates some of the problems of SFGs, specifically that they don't require Visual Studio. It still requires MSBuild, but you are probably using MSBuild to build your .NET solutions, even if you aren't using the Visual Studio IDE.

It turns out that .resx files also use an MSBuild task to perform part of their work. While the SFG generates C# code to provide an API for accessing your resources, the actual resource that gets embedded is handled by an MSBuild task. This generated .resources file doesn't get included in your source code; instead it is hidden away within the temporary output (obj) folder when you build. This is good, because it is a binary format, so would be un-diffable and unmergable.

So, why doesn't .resx use an MSBuild task to generate the C# code as well? If it did, then it wouldn't require Visual Studio at all. It could also output the generated code to the temporary output folder so it wouldn't be included in source. The reason for this is Intellisense.

For Intellisense to function, the IDE needs to be able to read all of the source files for a project. The IDE doesn't do a full rebuild every time a file is changed. This would be way too slow, and would result in an unpleasant developmente experience. By generating output using an SFG, the output is regenerated any time the .resx is modified in Visual Studio. The output code file is then visible to the IDE and thus appears in the intellisense list. Since a full build isn't performed, your custom MSBuild tasks won't have a chance to run to produce their output. No output, no Intellisense.

The final failing of resx files is the verbosity they add to the csproj file. Adding a single resx file will add thirteen lines to your csproj file. This is true for old-style as well as new-style "sdk" project files. These lines aren't particularly interesting to us, but are required to drive the Visual Studio project system.

```xml
  <ItemGroup>
    <Compile Update="Resource1.Designer.cs">
      <DesignTime>True</DesignTime>
      <AutoGen>True</AutoGen>
      <DependentUpon>Resource1.resx</DependentUpon>
    </Compile>
  </ItemGroup>

  <ItemGroup>
    <EmbeddedResource Update="Resource1.resx">
      <Generator>ResXFileCodeGenerator</Generator>
      <LastGenOutput>Resource1.Designer.cs</LastGenOutput>
    </EmbeddedResource>
  </ItemGroup>
```

At least, that is what I thought. I submitted [a proposal to the C# compiler team](https://github.com/dotnet/roslyn/issues/14468) to suggest an improvement to these options, expanding upon a [generators feature](https://github.com/dotnet/roslyn/blob/master/docs/features/generators.md) that is on their proposed roadmap. I proposed this with the hope that in some utopian future I would be able to create a DSL with all the benefits but none of the drawbacks: I could build from the command line, none of the generated code would be source controlled, and I would get live Intellisense in Visual Studio. As it turns out, we already live in that Utopian future, I just didn't realize it.

In my next post, I'll reveal how to implement a .resx style DSL for .NET that does just this.